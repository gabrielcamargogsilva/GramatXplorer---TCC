from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
import os
from dotenv import load_dotenv
import json
import re

app = Flask(__name__)
CORS(app)
load_dotenv()

GROQ_API_KEY = os.getenv("GROQ_API_KEY")
GROQ_URL = "https://api.groq.com/openai/v1/chat/completions"

# üîπ Rota raiz
@app.route('/')
def home():
    return "<h1>API est√° on</h1>"


def chamar_groq(mensagem_user, mensagem_sistema=""):
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json"
    }

    body = {
        "model": "llama-3.1-8b-instant", # Mantido o modelo que voc√™ especificou
        "messages": [
            {"role": "system", "content": mensagem_sistema},
            {"role": "user", "content": mensagem_user}
        ],
        "temperature": 0.7,
    }

    try:
        response = requests.post(GROQ_URL, headers=headers, json=body)
        response.raise_for_status() # Isso levantar√° um erro HTTP para status codes 4xx/5xx
        resposta = response.json()
        return resposta['choices'][0]['message']['content'].strip(), 200
    except requests.exceptions.RequestException as e:
        print(f"Erro ao chamar Groq API: {e}")
        return None, 500 # Retorna None e um status de erro em caso de falha

@app.route('/vialactea/pergunta', methods=['GET'])
def gerar_pergunta():
    nivel = request.args.get('nivel', 'm√©dio').lower()
    tema_solicitado = request.args.get('tema', '').lower()

    if nivel not in ['facil', 'medio', 'dificil']:
        return jsonify({"erro": "N√≠vel inv√°lido. Use: f√°cil, m√©dio ou dif√≠cil."}), 400

    temas_disponiveis = {
        'sintaxe': 'Sintaxe, com foco em **Sujeito e Predicado** (tipos, concord√¢ncia), e **Objetos Direto e Indireto** (diferencia√ß√£o, uso da preposi√ß√£o). Inclua exemplos pr√°ticos para identificar essas fun√ß√µes.',
        'pragmatica': "Pragm√°tica, abordando principalmente **Atos de Fala** (diretos/indiretos), **Ironia e Humor** (como s√£o constru√≠dos), **Regras de cortesia**, **Pressuposi√ß√£o**, **D√™ixis** e **Implicatura** (o que se subentende). A quest√£o deve exigir interpreta√ß√£o de contexto.",
        'morfologia': "Morfologia, com foco em **Radical, Afixos (prefixos e sufixos), Vogal Tem√°tica e Desin√™ncias** na forma√ß√£o e flex√£o das palavras. Pergunte sobre a estrutura das palavras ou sua classifica√ß√£o morfol√≥gica.",
    }

    # Garante que tema_para_prompt seja inicializado
    tema_para_prompt = "" 
    if tema_solicitado and tema_solicitado in temas_disponiveis:
        tema_para_prompt = temas_disponiveis[tema_solicitado]
    # Se o tema n√£o for v√°lido ou n√£o for fornecido, tema_para_prompt permanecer√° vazio,
    # o que far√° com que o prompt da IA n√£o inclua um tema espec√≠fico, gerando uma pergunta mais geral.

    contexto_dificuldade = {
        'facil': "Elabore a pergunta com vocabul√°rio mais simples, com foco em conte√∫dos b√°sicos e exemplos acess√≠veis.",
        'medio': "Use n√≠vel intermedi√°rio de complexidade, com exemplos contextualizados e exig√™ncia razo√°vel de an√°lise.",
        'dificil': "Inclua maior profundidade e complexidade na pergunta, exigindo maior dom√≠nio das regras gramaticais e interpreta√ß√£o sutil."
    }

    

    ### L√≥gica de Retentativa

    max_tentativas = 5  # Limite de tentativas para evitar loops infinitos
    tentativas = 0
    pergunta_valida = False
    
    # Vari√°veis para armazenar os dados da pergunta v√°lida
    pergunta_texto = "Pergunta n√£o encontrada"
    alternativas = {}
    letra_resposta = ""
    explicacao_texto = ""

    while not pergunta_valida and tentativas < max_tentativas:
        prompt = (
            f"{contexto_dificuldade[nivel]}\n\n"
            "Voc√™ √© um professor experiente de L√≠ngua Portuguesa voltado para o ensino m√©dio. "
            "Crie uma quest√£o de gram√°tica contextualizada, de m√∫ltipla escolha, com 4 alternativas (A, B, C, D), sendo apenas uma correta. "
            f"A quest√£o deve abordar conte√∫dos como: {tema_para_prompt} " 
            "Contextualize com uma frase ou pequeno trecho. "
            "Retorne a explica√ß√£o de forma extremamente resumida."
            "Formato:\n\n"
            "Pergunta: ...\n"
            "A) ...\nB) ...\nC) ...\nD) ...\nResposta correta: ...\nExplica√ß√£o: ..."
            "Retorne sempre a resposta correta." # Refor√ßa a instru√ß√£o para a IA
        )

        resposta_groq, status = chamar_groq(prompt, "Voc√™ √© um professor de portugu√™s criando quiz de m√∫ltipla escolha.")
        
        if not resposta_groq:
            # Se a chamada √† Groq falhar (e retornar None), paramos as tentativas
            print(f"Erro na chamada da Groq na tentativa {tentativas + 1}.")
            break # Sai do loop while

        # Extrair pergunta
        pergunta_match = re.search(r"Pergunta:\s*(.*?)(?=\nA\))", resposta_groq, re.DOTALL)
        pergunta_texto = pergunta_match.group(1).strip() if pergunta_match else ""

        # Extrair alternativas
        alternativas_match = re.findall(r"([ABCD])\)\s*(.*?)\n(?=[A-D]\)|Resposta correta:)", resposta_groq, re.DOTALL)
        alternativas = {letra: texto.strip() for letra, texto in alternativas_match}

        # Extrair letra da resposta correta
        resposta_match = re.search(r"Resposta correta:\s*([ABCD])", resposta_groq)
        letra_resposta = resposta_match.group(1).strip() if resposta_match else ""

        # Extrair explica√ß√£o
        explicacao_match = re.search(r"Explica√ß√£o:\s*(.*)", resposta_groq, re.DOTALL)
        explicacao_texto = explicacao_match.group(1).strip() if explicacao_match else ""
        explicacao_texto = re.sub(r"A resposta correta √© [ABCD]\).*", "", explicacao_texto).strip()

        # --- Valida√ß√£o da Pergunta ---
        # A pergunta √© v√°lida se tiver: texto da pergunta, 4 alternativas (incluindo D), e uma resposta correta
        if pergunta_texto and 'D' in alternativas and len(alternativas) == 4 and letra_resposta:
            pergunta_valida = True
        else:
            print(f"Tentativa {tentativas + 1} falhou: Pergunta '{pergunta_texto}', Alternativas {list(alternativas.keys())}, Resposta Correta '{letra_resposta}'. Retentando...")
            tentativas += 1
            
    # Se depois de todas as tentativas a pergunta ainda n√£o for v√°lida
    if not pergunta_valida:
        return jsonify({"erro": "N√£o foi poss√≠vel gerar uma pergunta v√°lida ap√≥s m√∫ltiplas tentativas. Tente novamente."}), 500

    # Garantir que todas as alternativas estejam presentes, caso a Groq retorne algo inesperado
    # (Embora o loop de retentativa j√° ajude bastante, esta √© uma √∫ltima garantia)
    for letra in ['A', 'B', 'C', 'D']:
        if letra not in alternativas:
            alternativas[letra] = "[alternativa n√£o fornecida]"

    return jsonify({
        "nivel": nivel,
        "tema": tema_solicitado, 
        "pergunta": pergunta_texto,
        "alternativas": alternativas,
        "resposta": letra_resposta,
        "explicacao": explicacao_texto
    }), 200

@app.route('/vialactea/verificar', methods=['POST'])
def verificar_resposta():
    dados = request.json
    pergunta = dados.get("pergunta", "")
    alternativas = dados.get("alternativas", {})
    resposta_usuario = dados.get("resposta", "")
    explicacao_texto = dados.get("explicacao", "")

    if not pergunta or not alternativas or not resposta_usuario:
        return jsonify({"erro": "Dados incompletos"}), 400

    # Montar a pergunta completa com as alternativas
    pergunta_completa = pergunta + "\n\n"
    for letra, texto in alternativas.items():
        pergunta_completa += f"{letra}) {texto}\n"

    resposta_correta = dados.get("resposta", "").strip().upper()
    resposta_usuario = resposta_usuario.strip().upper()

    # Montar prompt para avalia√ß√£o
    prompt = (
        f"Aqui est√° uma pergunta de portugu√™s:\n\n{pergunta_completa}\n"
        f"Resposta correta: {resposta_correta}\n"
        f"O usu√°rio escolheu: {resposta_usuario}\n"
        f"Avalie se ele acertou ou errou, se ele errou retorne a {resposta_correta} e o {explicacao_texto} de forma simples e did√°tica.\n"
        f"Use linguagem clara e adequada ao ensino m√©dio."
        f"Se a resposta estiver correta, retorne 'Correto'. Se estiver errada, retorne 'Incorreto'."
        f"Evite usar frases longas ou complexas. "

    )

    resposta, status = chamar_groq(prompt, "Voc√™ √© um corretor experiente de provas de L√≠ngua Portuguesa. Avalie a resposta do aluno.")
    if not resposta:
        return jsonify({"erro": "Erro ao verificar resposta"}), status

    return jsonify({
        "avaliacao": resposta,
        "correta": resposta_usuario == resposta_correta
    }), 200



@app.route('/andromeda/texto_usuario', methods=['GET'])
def gerar_texto_com_erros():
    prompt = (
        "Voc√™ √© um professor de L√≠ngua Portuguesa criando um exerc√≠cio com erros gramaticais. "
        "Crie um par√°grafo curto (3 a 5 linhas), informal, com 4 a 6 erros. "
        "Os erros podem envolver figuras de linguagem, vozes, paralinguagem, varia√ß√£o lingu√≠stica, morfologia, tempos verbais, sintaxe, conjun√ß√µes e reg√™ncia. "
        "N√£o corrija nem explique os erros. Apenas gere o texto com os desvios inseridos."
        "O texto deve ser informal, como se fosse uma conversa entre amigos. "
        "N√£o use palavras dif√≠ceis ou jarg√µes t√©cnicos. "
        "Retorne somente o texto com erros, sem mensagem ao usu√°rio no final"
    )

    resposta, status = chamar_groq(prompt, "Voc√™ √© um professor gerando textos com erros para corre√ß√£o de alunos.")
    if not resposta:
        return jsonify({"erro": "Erro ao gerar texto"}), status

    return jsonify({"texto_com_erros": resposta}), 200

@app.route('/andromeda/correcao', methods=['POST'])
def analisar_correcao():
    dados = request.json
    texto_original = dados.get("original", "")
    texto_usuario = dados.get("correcao", "")

    if not texto_original or not texto_usuario:
        return jsonify({"erro": "Dados incompletos"}), 400

    prompt = f"""
        f"Voc√™ √© um professor corrigindo texto de alunos. Avalie a corre√ß√£o do aluno. Seja did√°tico. Use linguagem clara e adequada ao ensino m√©dio.\n\n"
        "Texto com erros:\n\n{texto_original}\n\n"
        "Texto corrigido pelo aluno:\n\n{texto_usuario}\n\n"
        "Avalie a corre√ß√£o do aluno seguindo as instru√ß√µes abaixo:\n"
        "1. Liste os erros corrigidos corretamente (m√°ximo 4 linhas).\n"
        "2. Liste os erros que permanecem ou foram corrigidos de forma errada (m√°ximo 4 linhas).\n"
        "3. Explique de forma bem did√°tica e simples, sem usar palavras dif√≠ceis ou jarg√µes t√©cnicos.\n"
        "4. Informe apenas o n√∫mero de erros corrigidos corretamente e o n√∫mero de erros que permanecem ou foram corrigidos de forma errada.\n"
        Devolva no formato JSON se acordo com o modelo:
                {{
                    "corretos": ["lista de erros corrigidos corretamente, cada item uma string"],
                    "incorretos": ["lista de erros que permanecem ou foram corrigidos de forma errada, cada item uma string"],
                    "explicacao": "explica√ß√£o did√°tica, simples e resumida",
                    "erros_corrigidos": 2,
                    "erros_incorretos": 3
                }}

                "As chaves 'corretos' e 'incorretos' devem ser listas de strings, onde cada string descreve um erro."
        "6. A explica√ß√£o deve ser curta e clara, como se estivesse ensinando para um aluno do ensino m√©dio.\n"
        "7. N√£o use frases longas, complexas ou t√©cnicas.\n"
        "8. N√£o escreva nada fora do JSON."
            """


    resposta, status = chamar_groq(prompt, "Voc√™ √© um professor corrigindo reda√ß√µes de alunos. Avalie a corre√ß√£o do aluno. Seja did√°tico. Use linguagem clara e adequada ao ensino m√©dio.")

    if not resposta:
        return jsonify({"erro": "Erro ao avaliar corre√ß√£o"}), status

    try:
        # Tenta encontrar o JSON na string bruta da resposta
        # Procura pelo primeiro '{' e o √∫ltimo '}'
        start_index = resposta.find('{')
        end_index = resposta.rfind('}')

        if start_index != -1 and end_index != -1 and start_index < end_index:
            # Extrai a substring que parece ser o JSON
            json_string = resposta[start_index : end_index + 1]
            # Tenta carregar o JSON
            return jsonify(json.loads(json_string)), 200
        else:
            # Se n√£o conseguir encontrar um JSON v√°lido, retorna o erro original
            return jsonify({"erro": "N√£o foi poss√≠vel extrair um JSON v√°lido da resposta da IA", "resposta_bruta": resposta}), 500

    except json.JSONDecodeError as e:
        # Se a IA n√£o retornar JSON v√°lido ou houver outro erro de decodifica√ß√£o
        return jsonify({"erro": f"Erro ao decodificar JSON: {e}", "resposta_bruta": resposta}), 500
    except Exception as e:
        # Captura outras exce√ß√µes inesperadas
        return jsonify({"erro": f"Erro inesperado: {e}", "resposta_bruta": resposta}), 500


  

if __name__ == '__main__':
    app.run(debug=True)
