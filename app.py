from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
import os
from dotenv import load_dotenv
import json
import re

app = Flask(__name__)
CORS(app)
load_dotenv()

GROQ_API_KEY = os.getenv("GROQ_API_KEY")
GROQ_URL = "https://api.groq.com/openai/v1/chat/completions"

# üîπ Rota raiz
@app.route('/')
def home():
    return "<h1>API est√° on</h1>"


def chamar_groq(mensagem_user, mensagem_sistema=""):
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json"
    }

    body = {
        "model": "llama-3.1-8b-instant",
        "messages": [
            {"role": "system", "content": mensagem_sistema},
            {"role": "user", "content": mensagem_user}
        ],
        "temperature": 0.7,
    }

    response = requests.post(GROQ_URL, headers=headers, json=body)
    if response.status_code != 200:
        return None, response.status_code

    resposta = response.json()
    return resposta['choices'][0]['message']['content'].strip(), 200



@app.route('/vialactea/pergunta', methods=['GET'])
def gerar_pergunta():
    nivel = request.args.get('nivel', 'm√©dio').lower()
    # 1. Obter o tema solicitado ANTES de us√°-lo na l√≥gica
    tema_solicitado = request.args.get('tema', '').lower()

    if nivel not in ['facil', 'medio', 'dificil']:
        return jsonify({"erro": "N√≠vel inv√°lido. Use: f√°cil, m√©dio ou dif√≠cil."}), 400

    # 2. Definir o dicion√°rio de temas DISPON√çVEIS
    temas_disponiveis = {
        'sintaxe': 'Sintaxe, com foco em **Sujeito e Predicado** (tipos, concord√¢ncia), e **Objetos Direto e Indireto** (diferencia√ß√£o, uso da preposi√ß√£o). Inclua exemplos pr√°ticos para identificar essas fun√ß√µes.',
        'pragmatica': "Pragm√°tica, abordando principalmente **Atos de Fala** (diretos/indiretos), **Ironia e Humor** (como s√£o constru√≠dos), **Regras de cortesia**, **Pressuposi√ß√£o**, **D√™ixis** e **Implicatura** (o que se subentende). A quest√£o deve exigir interpreta√ß√£o de contexto.",
        'morfologia': "Morfologia, com foco em **Radical, Afixos (prefixos e sufixos), Vogal Tem√°tica e Desin√™ncias** na forma√ß√£o e flex√£o das palavras. Pergunte sobre a estrutura das palavras ou sua classifica√ß√£o morfol√≥gica.",
    }

    # 3. Validar o tema solicitado e definir 'tema_para_prompt'
    if tema_solicitado and tema_solicitado in temas_disponiveis:
        tema_para_prompt = temas_disponiveis[tema_solicitado]
    

    contexto_dificuldade = {
        'facil': "Elabore a pergunta com vocabul√°rio mais simples, com foco em conte√∫dos b√°sicos e exemplos acess√≠veis.",
        'medio': "Use n√≠vel intermedi√°rio de complexidade, com exemplos contextualizados e exig√™ncia razo√°vel de an√°lise.",
        'dificil': "Inclua maior profundidade e complexidade na pergunta, exigindo maior dom√≠nio das regras gramaticais e interpreta√ß√£o sutil."
    }

    prompt = (
        f"{contexto_dificuldade[nivel]}\n\n"
        "Voc√™ √© um professor experiente de L√≠ngua Portuguesa voltado para o ensino m√©dio. "
        "Crie uma quest√£o de gram√°tica contextualizada, de m√∫ltipla escolha, com 4 alternativas (A, B, C, D), sendo apenas uma correta. "
        f"A quest√£o deve abordar conte√∫dos como: {tema_para_prompt} " # Agora usa a vari√°vel definida corretamente
        "Contextualize com uma frase ou pequeno trecho. "
        "Retorne a explica√ß√£o de forma extremamente resumida"
        "Formato:\n\n"
        "Pergunta: ...\n"
        "A) ...\nB) ...\nC) ...\nD) ...\nResposta correta: ...\nExplica√ß√£o: ..."
    )

    resposta, status = chamar_groq(prompt, "Voc√™ √© um professor de portugu√™s criando quiz de m√∫ltipla escolha.")
    if not resposta:
        return jsonify({"erro": "Erro ao gerar pergunta"}), status

    # Extrair pergunta
    pergunta_match = re.search(r"Pergunta:\s*(.*?)(?=\nA\))", resposta, re.DOTALL)
    pergunta_texto = pergunta_match.group(1).strip() if pergunta_match else "Pergunta n√£o encontrada"

    # Extrair alternativas
    alternativas_match = re.findall(r"([ABCD])\)\s*(.*?)\n(?=[A-D]\)|Resposta correta:)", resposta, re.DOTALL)
    alternativas = {letra: texto.strip() for letra, texto in alternativas_match}

    # Garantir que todas estejam presentes
    for letra in ['A', 'B', 'C', 'D']:
        if letra not in alternativas:
            alternativas[letra] = "[alternativa n√£o fornecida]"

    # Extrair letra da resposta correta
    resposta_match = re.search(r"Resposta correta:\s*([ABCD])", resposta)
    letra_resposta = resposta_match.group(1).strip() if resposta_match else ""

    # Extrair explica√ß√£o ap√≥s "Explica√ß√£o:"
    explicacao_match = re.search(r"Explica√ß√£o:\s*(.*)", resposta, re.DOTALL)
    explicacao_texto = explicacao_match.group(1).strip() if explicacao_match else ""

    # Remover a frase "A resposta correta √©..." da explica√ß√£o
    explicacao_texto = re.sub(r"A resposta correta √© [ABCD]\).*", "", explicacao_texto).strip()

    return jsonify({
        "nivel": nivel,
        "tema": tema_solicitado, 
        "pergunta": pergunta_texto,
        "alternativas": alternativas,
        "resposta": letra_resposta,
        "explicacao": explicacao_texto
    }), 200

@app.route('/vialactea/verificar', methods=['POST'])
def verificar_resposta():
    dados = request.json
    pergunta = dados.get("pergunta", "")
    alternativas = dados.get("alternativas", {})
    resposta_usuario = dados.get("resposta", "")
    explicacao_texto = dados.get("explicacao", "")

    if not pergunta or not alternativas or not resposta_usuario:
        return jsonify({"erro": "Dados incompletos"}), 400

    # Montar a pergunta completa com as alternativas
    pergunta_completa = pergunta + "\n\n"
    for letra, texto in alternativas.items():
        pergunta_completa += f"{letra}) {texto}\n"

    resposta_correta = dados.get("resposta", "").strip().upper()
    resposta_usuario = resposta_usuario.strip().upper()

    # Montar prompt para avalia√ß√£o
    prompt = (
        f"Aqui est√° uma pergunta de portugu√™s:\n\n{pergunta_completa}\n"
        f"Resposta correta: {resposta_correta}\n"
        f"O usu√°rio escolheu: {resposta_usuario}\n"
        f"Avalie se ele acertou ou errou, se ele errou retorne a {resposta_correta} e o {explicacao_texto} de forma simples e did√°tica.\n"
        f"Use linguagem clara e adequada ao ensino m√©dio."
        f"Se a resposta estiver correta, retorne 'Correto'. Se estiver errada, retorne 'Incorreto'."
        f"Evite usar frases longas ou complexas. "

    )

    resposta, status = chamar_groq(prompt, "Voc√™ √© um corretor experiente de provas de L√≠ngua Portuguesa. Avalie a resposta do aluno.")
    if not resposta:
        return jsonify({"erro": "Erro ao verificar resposta"}), status

    return jsonify({
        "avaliacao": resposta,
        "correta": resposta_usuario == resposta_correta
    }), 200



@app.route('/andromeda/texto_usuario', methods=['GET'])
def gerar_texto_com_erros():
    prompt = (
        "Voc√™ √© um professor de L√≠ngua Portuguesa criando um exerc√≠cio com erros gramaticais. "
        "Crie um par√°grafo curto (3 a 5 linhas), informal, com 4 a 6 erros. "
        "Os erros podem envolver figuras de linguagem, vozes, paralinguagem, varia√ß√£o lingu√≠stica, morfologia, tempos verbais, sintaxe, conjun√ß√µes e reg√™ncia. "
        "N√£o corrija nem explique os erros. Apenas gere o texto com os desvios inseridos."
        "O texto deve ser informal, como se fosse uma conversa entre amigos. "
        "N√£o use palavras dif√≠ceis ou jarg√µes t√©cnicos. "
        "Retorne somente o texto com erros, sem mensagem ao usu√°rio no final"
    )

    resposta, status = chamar_groq(prompt, "Voc√™ √© um professor gerando textos com erros para corre√ß√£o de alunos.")
    if not resposta:
        return jsonify({"erro": "Erro ao gerar texto"}), status

    return jsonify({"texto_com_erros": resposta}), 200

@app.route('/andromeda/correcao', methods=['POST'])
def analisar_correcao():
    dados = request.json
    texto_original = dados.get("original", "")
    texto_usuario = dados.get("correcao", "")

    if not texto_original or not texto_usuario:
        return jsonify({"erro": "Dados incompletos"}), 400

    prompt = f"""
        f"Voc√™ √© um professor corrigindo texto de alunos. Avalie a corre√ß√£o do aluno. Seja did√°tico. Use linguagem clara e adequada ao ensino m√©dio.\n\n"
        "Texto com erros:\n\n{texto_original}\n\n"
        "Texto corrigido pelo aluno:\n\n{texto_usuario}\n\n"
        "Avalie a corre√ß√£o do aluno seguindo as instru√ß√µes abaixo:\n"
        "1. Liste os erros corrigidos corretamente (m√°ximo 4 linhas).\n"
        "2. Liste os erros que permanecem ou foram corrigidos de forma errada (m√°ximo 4 linhas).\n"
        "3. Explique de forma bem did√°tica e simples, sem usar palavras dif√≠ceis ou jarg√µes t√©cnicos.\n"
        "4. Informe apenas o n√∫mero de erros corrigidos corretamente e o n√∫mero de erros que permanecem ou foram corrigidos de forma errada.\n"
        Devolva no formato JSON se acordo com o modelo:
                {{
                    "corretos": ["lista de erros corrigidos corretamente, cada item uma string"],
                    "incorretos": ["lista de erros que permanecem ou foram corrigidos de forma errada, cada item uma string"],
                    "explicacao": "explica√ß√£o did√°tica, simples e resumida",
                    "erros_corrigidos": 2,
                    "erros_incorretos": 3
                }}

                "As chaves 'corretos' e 'incorretos' devem ser listas de strings, onde cada string descreve um erro."
        "6. A explica√ß√£o deve ser curta e clara, como se estivesse ensinando para um aluno do ensino m√©dio.\n"
        "7. N√£o use frases longas, complexas ou t√©cnicas.\n"
        "8. N√£o escreva nada fora do JSON."
            """


    resposta, status = chamar_groq(prompt, "Voc√™ √© um professor corrigindo reda√ß√µes de alunos. Avalie a corre√ß√£o do aluno. Seja did√°tico. Use linguagem clara e adequada ao ensino m√©dio.")

    if not resposta:
        return jsonify({"erro": "Erro ao avaliar corre√ß√£o"}), status

    try:
        # Tenta encontrar o JSON na string bruta da resposta
        # Procura pelo primeiro '{' e o √∫ltimo '}'
        start_index = resposta.find('{')
        end_index = resposta.rfind('}')

        if start_index != -1 and end_index != -1 and start_index < end_index:
            # Extrai a substring que parece ser o JSON
            json_string = resposta[start_index : end_index + 1]
            # Tenta carregar o JSON
            return jsonify(json.loads(json_string)), 200
        else:
            # Se n√£o conseguir encontrar um JSON v√°lido, retorna o erro original
            return jsonify({"erro": "N√£o foi poss√≠vel extrair um JSON v√°lido da resposta da IA", "resposta_bruta": resposta}), 500

    except json.JSONDecodeError as e:
        # Se a IA n√£o retornar JSON v√°lido ou houver outro erro de decodifica√ß√£o
        return jsonify({"erro": f"Erro ao decodificar JSON: {e}", "resposta_bruta": resposta}), 500
    except Exception as e:
        # Captura outras exce√ß√µes inesperadas
        return jsonify({"erro": f"Erro inesperado: {e}", "resposta_bruta": resposta}), 500


  

if __name__ == '__main__':
    app.run(debug=True)
